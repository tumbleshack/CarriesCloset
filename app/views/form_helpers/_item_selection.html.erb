<script>

  function getBody() {
    return document.getElementById("table-body");
  }

  function updateItemTypes(element) {
    var items = <%= raw @allItems.to_json %>;
    var categories = <%= raw @allCategories.to_json %>;
    var categoryValue = element.value;
    var row = element.parentElement.parentElement;
    var itemSelector = row.querySelector('[data-selectortype$="itemType"]');

    for(var i = itemSelector.options.length - 1; i >= 0; i--) {
      itemSelector.remove(i);
    }

    console.log(categories);

    const matchedCategory = categories.find(c => c.id == categoryValue);
    if (matchedCategory) {
      const categoryID = matchedCategory.id;
      const itemsForCategoryRaw = items.filter(i => i.category_id == categoryID);

      const itemsForCategory = toUnique(itemsForCategoryRaw);

      for (var i = 0; i < itemsForCategory.length; i++) {
        var newOption = document.createElement('option');
        newOption.value = itemsForCategory[i].itemType;
        newOption.innerHTML = itemsForCategory[i].itemType;
        itemSelector.appendChild(newOption);
      }
    }

    updateItemSizes(itemSelector);
  }

  function updateItemSizes(element) {
    var items = <%= raw @allItems.to_json %>;
    var categories = <%= raw @allCategories.to_json %>;
    var itemTypeName = element.value;

    var row = element.parentElement.parentElement;
    var sizeSelector = row.querySelector('[data-selectortype$="size"]');

    for(var i = sizeSelector.options.length - 1; i >= 0; i--) {
      sizeSelector.remove(i);
    }

    const matchedItem = items.find(i => i.itemType == itemTypeName);
    if (matchedItem) {
      const itemID = matchedItem.id;
      const sizesForItemRaw = items.filter(i => i.id == itemID).map(i => i.size);
      const sizesForItem = toUnique(sizesForItemRaw);

      for (var i = 0; i < sizesForItem.length; i++) {
        var newOption = document.createElement('option');
        newOption.value = sizesForItem[i];
        newOption.innerHTML = sizesForItem[i];
        sizeSelector.appendChild(newOption);
      }
    }
  }

  function getAllRows() {
    const body = getBody();
    return [ ...body.childNodes ].filter(element => element.tagName == "TR");
  }

  function getLastRow() {
    const body = getBody();
    const prevRows = [ ...body.childNodes ].filter(element => element.tagName == "TR");
    var maxIndex = -1;
    var maxRow = null;
    prevRows.forEach(row => {
      row.childNodes.forEach(td => {
        if (td.tagName == "TD") {
          td.childNodes.forEach(field => {
            let inx = extractIndexFromName(field.name);
            if ((inx != null) && inx[0] > maxIndex) {
              maxIndex = inx[0];
              maxRow = row;
            }
          });
        }
      });
    });
    return maxRow;
  }

  function extractIndexFromName(name) {
    if (!name) return null;
    const regex = /\[(\d)+\]/;
    const found = name.match(regex);
    if (!found) return null;
    return [parseInt(found[0].substring(1, found[0].length - 1)), found.index]
  }

  function allDescendants (root, doSomethingToNode) { 
    root.childNodes.forEach(child => { 
       allDescendants(child, doSomethingToNode);
       doSomethingToNode(child);   
    }); 
  }

  function insertItemRow() {
    const body = getBody();
    const prevRow = getLastRow();
    const clone = prevRow.cloneNode(true);
    clone.dataset.id = parseInt(clone.dataset.id) + 1;
    var categorySelector = null;
    
    const incrementNameAndIdIndex = (node) => {
      found = extractIndexFromName(node.name)
      if (found != null) {
        node.name = node.name.replace("[" + found[0] + "]", "[" + (found[0] + 1) + "]");
        node.id = node.id.replace("_" + found[0] + "_", "_" + (found[0] + 1) + "_");
        if (node.dataset.selectortype == "category") {
          node.onchange = function() { updateItemTypes(this); }
          categorySelector = node;
        } else if (node.dataset.selectortype == "itemType") {
          node.onchange = function() { updateItemSizes(this); }
        }
      }
    }

    allDescendants(clone, incrementNameAndIdIndex);
    body.appendChild(clone);
    updateItemTypes(categorySelector);
  }

  function removeItemRow(button) {
    if (getAllRows().length < 2) return;
    const index = button.parentNode.parentNode.dataset.id;
    const body = getBody();
    const selector = '[data-id="' + index + '"]';
    const row = body.querySelector(selector);
    body.removeChild(row);
  }

  function toUnique(array) { //array,placeholder,placeholder
    return array.filter(function(item, pos) {
      return array.indexOf(item) == pos;
    });
  }

</script>

<div class="field">
  <%= form.label :items, 'What items would you like to request?' %>
  <table id="items-table">
    <thead>
    <tr>
      <th>Quantity</th>
      <th>Category</th>
      <th>Item Type</th>
      <th>Size</th>
      <th></th>
    </tr>
    </thead>

    <tbody id="table-body">
      <%= form.simple_fields_for :item_changes do |item_change_form| %>
        <tr data-id=<%=item_change_form.index%>>
            <td><%= item_change_form.number_field :quantity %></td>
            <td><%= item_change_form.select :category_id, Category.all.map { |category| [ category.name, category.id ] }, options = {}, html_options = {:onchange => "updateItemTypes(this)", :data => { selectorType: "category" }} %></td>
            <td><%= item_change_form.select :itemType, Item.all.map{ |item| item.itemType }, options = {}, html_options = {:onchange => "updateItemSizes(this)", :data => { selectorType: "itemType" }} %></td>
            <td><%= item_change_form.select :size, Item.all.map{ |item| item.size }, options = {}, html_options = {:data => { selectorType: "size" }} %></td>
            <td hidden><%= item_change_form.hidden_field :change_type, value:ItemChange::CHANGE_TYPES.fetch(:request) %></td>
            <td><button type="button" onclick="removeItemRow(this);">Remove</button></td>
        </tr> 
      <%end%>
    </tbody>
  </table>
  <button type="button" onclick="insertItemRow();">Add Item</button> 
</div>